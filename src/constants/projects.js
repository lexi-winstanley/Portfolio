export default {
    projects: [
        {
            videoSrc: '',
            id: '12',
            imageSrc: 'images/urbanPrairieWheat.svg',
            imageAlt: '',
            background: '#0072bb',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/urbanPrairieMobile.png',
            desktopScreenshot: 'images/urbanPrairieDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Urban Prairie Homes',
            path: '/urban-prairie-homes',
            motivation: 'The client, a home builder in Fargo, ND, wanted to refresh their current website. The design needed to be responsive and allow for many pictures of the company\'s various floor plans so React was a natural choice to help improve performance. The company also has a modern aesthetic and wanted this to be reflected in the design of the new site.',
            description: 'This is a website created with React for Urban Prairie Homes. The emphasis when designing this website was on a clean aesthetic that would allow the photos from the company\'s current and past projects to shine.',
            technicalInfo: '',
            technologies: 'HTML, CSS, JavaScript, React, Amazon S3',
            npmPackages: '',
            futureDev: '',
            role: 'Part of a two person development team. Responsible for design, creation of custom graphics, front end code and integration with back end. Also responsible for all client interactions and communicating client requirements and desires to back end developer.',
            githubLink: '',
            projectLink: 'https://www.urbanprairiehomes.com/',
            javascript: true,
            node: false,
            jQuery: false,
            react: true,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: 'images/bri-SPYDemo.mp4',
            id: '19',
            imageSrc: 'images/bri-spy.svg',
            imageAlt: 'bri-spy icon',
            background: '#FC354C',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: '',
            mobileScreenshot: '',
            desktopScreenshot: '',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'bri-SPY',
            path: '/bri-spy',
            motivation: 'To begin learning React Native and create a mobile game that would feature beautiful images and be low stress and fun to play.',
            description: 'bri-SPY is a "Where\'s Waldo?" inspired React Native mobile game in which users pinch-to-zoom and pan to find the hidden character, Brian, then double tap to stop the clock and store their time. If their time beats the stored "Best Time" for that image they are notified.',
            technicalInfo: 'After the application loads the user is presented with a sign-in screen powered by Google Authentication, once the user successfully signs in an API call is made to the backend to check if the user exists in the MongoDB database. If they already exist their information is returned to personalize the user\'s display and allow for storage of their image solve times. If the user does not exist in the database their information is stored. The user can then choose from the library of images and begin playing. Once they click an image and press the "Start" button, a timer begins and the user can pinch-to-zoom and pan around the image in order to find the hidden icon. Once they find the icon they double tap which stops the timer and another API call is made to determine if they have beat the stored best time for that specific image. The user is alerted on the next screen if they achieved a new best time and is presented with the option to return to the image library or continue to the next image. The application also features a menu which opens as an overlay and pauses the timer during game play or allows users the option to exit their current image and return to the main screen where they can chose to sign out.',
            technologies: 'HTML, CSS, JavaScript, React Native, Expo, Node.js, Express, MongoDB, Mongoose, Heroku',
            npmPackages: 'express, mongoose, expo-font, expo-google-app-auth, expo-linear-gradient, react-native-extended stylesheet, react-native-gesture-handler, react-native-reanimated',
            futureDev: 'Continue developing the component which handles pinch-to-zoom, pan and double tap actions during game play to create a smoother experience. Also explore options to create a higher resolution icon without sacrificing background image quality and decrease loading times for images. Allow users the option to create game specific usernames and create leaderboards. Add optional background music and sound effects. Continuing polishing with goal to release on Google Play Store and Apple App Store.',
            role: 'Technical lead of a three person development team. Collaborated with team members regarding application functionality and design. Helped team members as needed to deliver integration with Google Authentication, timer functionality and was responsible for all other code including the backend as well as styling to comply agreed upon design. Also created custom component to handle pinch-to-zoom, pan and double tap actions during game play.',
            githubLink: [
                'https://github.com/lexi-winstanley/bri-SPY',
                'https://github.com/lexi-winstanley/bri-SPYBackEnd'
            ],
            projectLink: '',
            javascript: true,
            node: true,
            jQuery: false,
            react: true,
            reactNative: true,
            mySQL: false,
            mongo: true,
            firebase: false,
            customGraphics: true,
            userAuth: true,
            api: true
        },
        {
            videoSrc: '',
            id: '23',
            imageSrc: 'images/somethingBorrowed.svg',
            imageAlt: '',
            background: '#45bce5',
            textColor: '#0F0F0D',
            mobileBackgroundSrc: 'images/phoneBackDark.svg',
            desktopBackgroundSrc: 'images/desktopDark.svg',
            mobileScreenshot: 'images/somethingBorrowedMobile.png',
            desktopScreenshot: 'images/somethingBorrowedDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Something Borrowed',
            path: '/something-borrowed',
            motivation: 'To create a web application to help users save money and reduce wasteful purchasing. The idea was inspired through the groups\' experiences purchasing items (video games, books, specialized home improvement tools, etc.) that are used only once or twice. Wouldn\'t it be great if you could see exactly what your friends, neighbors and acquaintances already have that they\'d be willing to lend you? Something Borrowed fills that need!',
            description: 'Something Borrowed facilitates friend-to-friend lending which helps users save money and reduce wasteful purchasing of items to be used only once or twice.',
            technicalInfo: 'On home page load users are presented with a landing page and the option to sign in or create an account. This process is handled using Google Authentication. Once users create an account they can create or request to join existing groups and add items they are willing to lend out to the members of those groups. They can view the items that the other group members have added and make requests to borrow them. The requester and item owner can then message back and forth until a location and time for pickup are agreed upon and then the owner can confirm the request. If a mutually agreeable location and time cannot be found the owner can deny the request or the requester can delete it. Users, items, groups and messages are all stored in MySQL and associated with each other as appropriate. Sequelize is used to handle MySQL connection and queries. This application is organized using the Model-View-Controller (MVC) design pattern. Once database data is gathered or altered, the view updates from the Handlebars templates using a page reload. Bootstrap was used as a jumping off point for styling and custom CSS rules were added as necessary to achieve desired layout and design.',
            technologies: 'HTML, Handlebars, CSS, JavaScript, jQuery, MySQL, Node.js, Express, Heroku',
            npmPackages: 'express, express-handlebars, mysql2, sequelize, google-auth-library, nodemailer, nodemon, dotenv, cookie-parser',
            futureDev: 'Some ideas for future development include integration with Google Maps and Calendar so that users can suggest locations and have calendar invites sent out automatically once exchange details have been agreed upon. Another idea would be to integrate with PayPal or another money handling service and allow users to set a deposit or fee for borrowing expensive items which could help mitigate concerns regarding items not being returned.',
            role: 'Part of a four person developer team. Contributed to design, responsible for creating media queries and altering as needed to make fully responsive. Authored code related to user authentication, storage of users in MySQL and API routes for users. Worked closely with other team members to complete all other MySQL storage/associations and API routes. Responsible for Handlebars templates and created graphic logo and favicon.',
            githubLink: 'https://github.com/lexi-winstanley/somethingBorrowed',
            projectLink: 'https://something---borrowed.herokuapp.com/',
            javascript: true,
            node: true,
            jQuery: true,
            react: false,
            reactNative: false,
            mySQL: true,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: true,
            api: true
        },
        {
            videoSrc: '',
            id: '9',
            imageSrc: 'images/packIt.svg',
            imageAlt: '',
            background: '#680a4d',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/packItMobile.png',
            desktopScreenshot: 'images/packItDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Pack It!',
            path: '/pack-it',
            motivation: 'To create something that would simplify an aspect of travel. In our experience, the most stressful part of a trip is generally the days leading up to it when you’re pressed for time and trying to remember and complete all the last minute to-dos at work or home, including packing your suitcases. We’ve all made lists of items to pack for trips before and this seemed like an area that could be streamlined as we often end up packing the same items trip after trip. We wanted to be able to dynamically generate a suggested list that the user could then further customize and save for later.',
            description: 'Pack It! is a web application that helps simplify the task of packing for a trip. The user inputs a destination and trip duration, Pack It! then gets a 5-day forecast for that location and suggests a packing list based on the weather and the trip duration. The location is also used to display webcams near the destination which can further inform the user’s packing plans.',
            technicalInfo: 'When a user navigates to Pack It! they are presented with a landing page where they input a destination and trip duration. These inputs are captured and the location is used to call the Open Weather Map API which returns forecast results for the next 120 hours (about five days) in three hour increments and the latitude and longitude of the forecast location. We then use that latitude and longitude to call the Webcams.Travel API which returns webcams within a 250 km (approximately 155 mile) radius which can help inform the user\'s packing plans. We display up to six webcam stills on our results page which users can click to navigate to the live stream. Using jQuery we loop through the forecast results from Open Weather Map and get the highest maximum temperature and lowest minimum temperature to display for each day. The weather description used is the first that occurs. The average high temperature over the entire forecast period is used to determine whether a warm weather or cold weather packing list should be suggested. The list display is then generated from an array. Once the user gets their results they can customize their list as desired and choose to create an account in order to save their list to our Firebase database. We use Firebase user authentication to create an email/password login and then a new node is created in our root directory using the user ID and the packing list is saved as an array. The next time the user visits Pack It! they can log in and retrieve their saved list.',
            technologies: 'HTML, CSS, Materialize, JavaScript, jQuery, OpenWeatherMap API, Webcams.Travel API, Firebase',
            npmPackages: '',
            futureDev: 'There are many features we\'d like to develop further in order to increase the utility of Pack It! for users. A basic improvement would be to add the ability to edit items in the packing list rather than just adding/deleting. A more significant new feature would be integrating with another weather API to provide historical weather for trips further in the future or adding the ability to add multiple destinations or activity parameters to the search to get more specific packing suggestions (i.e. skiing or snorkeling). Further customization options could be provided by allowing users to save multiple lists associated with specific search parameters. For example, users could have a \'Cruise\' list, a \'Skiing\' list, a \'Hawaii\' list, etc. Additional functionality would be the ability to edit the duration of a saved packing list and automatically updated the quantities. Saving the checked status of an item when the list is saved would also allow users greater freedom to pack in stages. For example, a user could log in the night before a trip when they get the majority of their packing done and then again the morning of travel to add in last minute items. This functionality would necessitate a way to reset all check boxes to improve the user experience for repeated uses of the list.',
            role: 'Part of a three person developer team. Contributed to design, responsible for altering as needed to make responsive. Authored code to capture user inputs, call Open Weather Map API, parse latitude and longitude to be used in call to Webcams.Travel API, average temperature data and serve appropriate packing list. Created custom weather graphics and favicon.',
            githubLink: 'https://github.com/lexi-winstanley/packIt',
            projectLink: 'https://lexi-winstanley.github.io/packIt/',
            javascript: true,
            node: false,
            jQuery: true,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: true,
            customGraphics: true,
            userAuth: true,
            api: true
        },
        {
            videoSrc: '',
            id: '16',
            imageSrc: 'images/threeScoreDev.svg',
            imageAlt: 'compass inspired black and green Three Score Development logo',
            background: '#cbc5ef',
            textColor: '#0F0F0D',
            mobileBackgroundSrc: 'images/phoneBackDark.svg',
            desktopBackgroundSrc: 'images/desktopDark.svg',
            mobileScreenshot: 'images/threeScoreDevMobile.png',
            desktopScreenshot: 'images/threeScoreDevDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Three Score Development',
            path: '/three-score-development',
            motivation: '',
            description: '',
            technicalInfo: '',
            technologies: 'HTML, ThymeLeaf, CSS, Acuity Scheduling integration and customization, Java',
            npmPackages: '',
            futureDev: '',
            role: 'Part of a two member development team. Responsible for design, HTML/Thymeleaf, CSS, client interactions and creation of custom graphics. Also completed integration with Acuity Scheduling and customized appearance with CSS.',
            githubLink: '',
            projectLink: 'https://www.threescoredevelopment.com/',
            javascript: false,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '20',
            imageSrc: 'images/chapterToo.svg',
            imageAlt: 'Chapter Too white and grey sailboat icon',
            background: '#041232',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/chapterTooMobile.png',
            desktopScreenshot: 'images/chapterTooDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Chapter Too Travel Blog',
            path: '/chapter-too',
            motivation: '',
            description: '',
            technicalInfo: '',
            technologies: 'HTML, CSS, Java',
            npmPackages: '',
            futureDev: '',
            role: 'Part of a two person development team. Responsible for design, HTML/Thymeleaf and CSS, client interactions and creation of custom graphics.',
            githubLink: '',
            projectLink: 'https://www.mvchaptertoo.com/',
            javascript: false,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '24',
            imageSrc: 'images/threeScoreRub.svg',
            imageAlt: 'Three Score Rub Original jar icon',
            background: '#0072bb',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/threeScoreRubMobile.png',
            desktopScreenshot: 'images/threeScoreRubDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Three Score Rub',
            path: '/three-score-rub',
            motivation: '',
            description: '',
            technicalInfo: '',
            technologies: 'HTML, Thymeleaf, CSS, Java',
            npmPackages: '',
            futureDev: '',
            role: 'Part of a two person development team. Responsible for design, HTML/Thymeleaf and CSS, client interactions and creation of custom graphics.',
            githubLink: '',
            projectLink: 'https://threescorerub.com/',
            javascript: true,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '13',
            imageSrc: 'images/swissFavicon.svg',
            imageAlt: 'polaroid icon with Swiss cross',
            background: '#b5ca30',
            textColor: '#0F0F0D',
            mobileBackgroundSrc: 'images/phoneBackDark.svg',
            desktopBackgroundSrc: 'images/desktopDark.svg',
            mobileScreenshot: 'images/swissMemoryMobile.png',
            desktopScreenshot: 'images/swissMemoryDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Swiss Memory Game',
            path: '/swiss-memory-game',
            motivation: 'To create a React memory game in which the goal is to click each displayed image once without repeating any clicks while the images shuffle.',
            description: 'This is a memory game created with React utilizing photos from Switzerland. The goal is to click all of the photos without repeating clicking any twice, the catch is that the photos shuffle after each click!',
            technicalInfo: 'The main functionality of this application comes from a React class component which stores essential game information in its state including the array of photos, an array of clicked photos, the score, top score, number of wins and selected level of difficulty. When the application loads the user is presented with a screen to pick their difficulty: easy, medium or hard. Once they select a level 8, 16 or 24 of the photos are selected at random and added to an array. The state is updated to reflect this array and the stage of the game which results in a DOM update. The chosen photos are displayed for the user to begin clicking. Each time they click, the application compares the photo\'s ID to those in the clicked photos array to confirm the photo has not already been clicked. If the click is not a repeat that photo\'s ID is added to the clicked photos array and the array is then shuffled before re-rendering. If the photo has been clicked before the user is presented with a "Game Over" screen and presented with the option to re-select difficulty and play again. If the user successfully clicks through all the photos without any repeats they are presented with a "Success" screen and the option to restart the game.',
            technologies: 'HTML, CSS, JavaScript, React',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/swissMemoryGame',
            projectLink: 'https://lexi-winstanley.github.io/swissMemoryGame/',
            javascript: true,
            node: false,
            jQuery: false,
            react: true,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '29',
            imageSrc: 'images/burger.svg',
            imageAlt: 'double decker burger icon',
            background: '#0072bb',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/burgerMobile.png',
            desktopScreenshot: 'images/burgerDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Eat Da Burger',
            path: '/eat-da-burger',
            motivation: 'To create a web application to display content from a MySQL database based on a boolean condition which will update on button press. Users should also be able to add new content. The user interface will be created using Handlebars templates and a custom ORM (Object Relational Mapper) will be used to simplify database interactions.',
            description: 'Eat Da Burger is a web application that displays lists of \'Ready to Eat\' or \'Devoured\' burgers to users from a MySQL database. They can then \'Devour\' or add new burgers as desired.',
            technicalInfo: 'This application is organized using the Model-View-Controller (MVC) design pattern and deployed with Heroku. An Object Relational Mapper (ORM) is defined with functions to handle the MySQL queries and the model further defines those functions specific to the Eat Da Burger application. The routing is defined in the controller and the functions are called as appropriate, once database data is gathered or altered, the view updates from the Handlebars template using a page reload. On home page load, the user is presented with any existing burgers in the MySQL database, non-devoured burgers in the \'Ready to Eat\' section and devoured burgers in the \'Devoured\' section. There is also a form to allow them to input the name of new burgers they\'d like to eat. Once they hit submit, the new burger is added to the MySQL database as \'Ready to Eat\' and the page is reloaded so the burger is displayed in the appropriate section with a \'Devour It!\' button. If the user clicks this button the devoured state for that burger is updated in the MySQL database and the page is reloaded showing the burger moved to the \'Devoured\' section of the page.',
            technologies: 'HTML, Handlebars, CSS, JavaScript, jQuery, MySQL, Node.js, Express, Heroku',
            npmPackages: 'express, express-handlebars, mysql',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/burgerLog',
            projectLink: 'https://nameless-taiga-35229.herokuapp.com/',
            javascript: true,
            node: true,
            jQuery: true,
            react: false,
            reactNative: false,
            mySQL: true,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: true
        },
        {
            videoSrc: '',
            id: '10',
            imageSrc: 'images/gifGenerator.svg',
            imageAlt: 'gif generator icon',
            background: '#041232',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/gifMobile.png',
            desktopScreenshot: 'images/gifDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'GIF Generator',
            path: '/gif-generator',
            motivation: 'Use the Giphy API to search for GIFs matching a certain search query. Allow users to use pre-defined buttons or create their own. Display results attractively.',
            description: 'Press the buttons to search for animal GIFs. You can add your own buttons to create custom searches. Each search will return 10 GIFs but you can press the \'Get More\' button after the initial search to return additional GIFs in that category. You can expand or collapse the favorites section by pressing the arrow and you can press any \'Add to Favorites\' button to add that GIF to the section.',
            technicalInfo: 'Logic was written to capture user text input to create new buttons that can then be clicked (click event listeners) to call the Giphy API with the search query. A response is received from the Giphy API and the JSON data is used to display the GIFs on the page. If the API call is not successful, an error is shown.',
            technologies: 'HTML, CSS, JavaScript, jQuery, Giphy API',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/giphyGenerator',
            projectLink: 'https://lexi-winstanley.github.io/giphyGenerator/',
            javascript: true,
            node: false,
            jQuery: true,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: true
        },
        {
            videoSrc: '',
            id: '15',
            imageSrc: 'images/friendFinder.svg',
            imageAlt: 'friend finder icon',
            background: '#680a4d',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/friendFinderMobile.png',
            desktopScreenshot: 'images/friendFinderDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Friend Finder',
            path: '/friend-finder',
            motivation: 'To create an application that would take in data from user surveys, execute logic to find their most compatible match from a stored list and display that to them.',
            description: 'Friend Finder is a web application deployed with Heroku. Users answer survey questions and are then based on their answers are shown their best stored friend match.',
            technicalInfo: 'The user is first brought to a landing page that has a button linking them to the survey page where they will be asked to answer a few questions. Once they submit the form, their answers are captured and compared with stored friends\' data. The stored friend with the lowest absolute difference from the scores will be returned as the user\'s best possible friend match. This application is organized into an app directory which is subdivided into data, public and routing folders. The data folder holds the stored friends data as an array of objects, the public folder holds the HTML and images while the routing folder holds files defining the API and HTML routes. A server file initializes the server and brings together the other resources as necessary to enable the application\'s functionality.',
            technologies: 'HTML, Bootstrap, JavaScript, jQuery, Node.js, Express, Heroku',
            npmPackages: 'express, path',
            futureDev: '',
            role: 'Sole developer responsible for code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/friendFinder',
            projectLink: 'https://afternoon-falls-93974.herokuapp.com/',
            javascript: true,
            node: true,
            jQuery: true,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: true
        },
        {
            videoSrc: '',
            id: '22',
            imageSrc: 'images/train.svg',
            imageAlt: 'olive green, black and grey train logo',
            background: '#cbc5ef',
            textColor: '#0F0F0D',
            mobileBackgroundSrc: 'images/phoneBackDark.svg',
            desktopBackgroundSrc: 'images/desktopDark.svg',
            mobileScreenshot: 'images/trainMobile.png',
            desktopScreenshot: 'images/trainDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Train Schedule',
            path: '/train-schedule',
            motivation: 'To create an application that displays train times from a Firebase database and allows site visitors to input in new train data which is saved to the database and then used to calculate the next arrival time and minutes away for each train.',
            description: 'This web application allows visitors to view a table with the names, destinations, frequencies, next arrivals and minutes to next arrivals of current trains stored in its Firebase database. The next arrival and minutes to next arrival columns are updated every 60 seconds. Visitors can also use the form on the page to add new trains to the database. They must provide the name, destination, frequency, and first arrival time. Next arrival time and minutes to next arrival time will be calculated upon data retrieval.',
            technicalInfo: 'Logic was written to capture user inputs and store them in Firebase database. A function is set to run on any changes to the database and then use values to calculate the minutes to next train arrival and next time arriving using the Moment.js library. These values are then dynamically displayed to the HTML in a table.',
            technologies: 'HTML, CSS, JavaScript, Firebase',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/trainSchedule',
            projectLink: 'https://lexi-winstanley.github.io/trainSchedule/',
            javascript: true,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: true,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '26',
            imageSrc: 'images/sawblade.svg',
            imageAlt: 'saw blade icon',
            background: '#0cb2ba',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/woodworkingMobile.png',
            desktopScreenshot: 'images/woodworkingDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Woodworking Trivia',
            path: '/woodworking-trivia',
            motivation: 'To create a JavaScript trivia game that displays timed questions for a user to answer, keeps track of number correct/incorrect and displays that information once all questions have been answered.',
            description: 'This trivia game is about woodworking. On page load an instruction screen is displayed. Once the player clicks the "Start Game" button the first question appears. The player is given a certain amount of time in which to answer the question. After they answer or time runs out, the correct answer will be confirmed or shown and a new question will load. The timer will reset each time a new question appears. Once the player has gone through all the questions a screen will display the total correct/incorrect answers. Not answering in the allotted time counts as an incorrect answer.',
            technicalInfo: 'Timeout functions and intervals are used to display the questions and a countdown of time to answer. Once the user answers a page is shown that reveals the correct answer. After a set amount of time the next question is shown and a new countdown begins. Once all the questions have been answered a summary screen is shown and the game is over.',
            technologies: 'HTML, CSS, JavaScript',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/woodworkingTrivia',
            projectLink: 'https://lexi-winstanley.github.io/woodworkingTrivia/',
            javascript: true,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '8',
            imageSrc: 'images/pawPrint.svg',
            imageAlt: 'dog paw print icon',
            background: '#b5ca30',
            textColor: '#0F0F0D',
            mobileBackgroundSrc: 'images/phoneBackDark.svg',
            desktopBackgroundSrc: 'images/desktopDark.svg',
            mobileScreenshot: 'images/dogBreedMobile.png',
            desktopScreenshot: 'images/dogBreedDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Guess that Dog Breed Game',
            path: '/guess-that-dog-breed',
            motivation: 'To create a JavaScript game in which blanks are displayed to represent the number of letters in an unknown word and a user then has a limited number of tries to guess the letters correctly to reveal the word.',
            description: 'This application randomly chooses a word from a predefined array of dog breeds, then displays underscores corresponding to the number of letters. The user then presses keys to guess letters that may be in the word. If they guess a letter that is in the word the appropriate blanks are changed to that letter and the number of letters remaining in the word decreases. If they guess a letter that is not in the word it is displayed on the page as an incorrect lettter guessed and the number of guesses remaining decreases.',
            technicalInfo: 'This application is written with JavaScript. Arrays are used to hold possible words, letters guessed incorrectly and correctly, underscores corresponding to current word and words that have been used since page load. Loops, variables and event listeners (on key up) are used to carry out the logic to determine what the user is guessing and if that guess is correct or not as well as update the HTML elements. The user is allowed 10 incorrect guesses, if they do not guess all the letters in the word before they run out of guesses the number of losses is incremented and the game resets. If they guess the word correctly then the number of wins is incremented and the game resets. When the game resets the computer randomly chooses a new word from the remaining dog breeds in the array and the incorrect guesses are cleared and number of guesses remaining set back to 10. Each time the computer selects a new word the picture is updated to display a dog of the previous breed (i.e. if the previous word was "poodle" when the computer selects a new word the picture will update to be of a poodle). The computer will go through each word in the array once before beginning to repeat words. There are 20 unique dog breeds in the game.',
            technologies: 'HTML, CSS, JavaScript',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/DogBreedGuessingGame',
            projectLink: 'https://lexi-winstanley.github.io/DogBreedGuessingGame/',
            javascript: true,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '17',
            imageSrc: 'images/greenCrystal.svg',
            imageAlt: 'green crystal icon',
            background: '#FC354C',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/crystalMobile.png',
            desktopScreenshot: 'images/crystalDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Crystal Counting',
            path: '/crystal-counting',
            motivation: 'To create a simple game utilizing jQuery in which the goal is to click the crystals, which have unknown values, in such a way that the sum equals the randomly generated target score.',
            description: 'At the start of the game a target score will be randomly generated. Each of the four crystals will also be assigned a random value not displayed to the player. Each time a crystal is clicked its value will be added to the current score. The object of the game is to click on the crystals in such a way that the sum of all the crystals clicked equals the target score.',
            technicalInfo: 'This is a JavaScript game utilizing the jQuery library. On page load, a random target score is generated between 19 and 120 using Math.random(). Random values are generated between 1 and 12 for each of the crystals using the same method and added to an array to be assigned. The target score and current score are displayed to the player while the crystal values are not. Each time a crystal is clicked a function runs to add its secret value will be added to the current score. With this information a player can use logic to figure out the crystal values and successfully reach the target score--or they can click randomly and hope for the best! If, after a click, the current score equals the target score, the player has won and the wins displayed at the bottom of the page will be incremented. If the current score goes over the target score the player has lost and the losses displayed at the bottom of the page will be incremented. Once the player wins or loses a new target score and crystal values will be generated.',
            technologies: 'HTML, CSS, JavaScript, jQuery',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/crystalCountingGame',
            projectLink: 'https://lexi-winstanley.github.io/crystalCountingGame/',
            javascript: true,
            node: false,
            jQuery: true,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        },
        {
            videoSrc: '',
            id: '27',
            imageSrc: 'images/crystalBall.svg',
            imageAlt: 'crystal ball icon',
            background: '#680a4d',
            textColor: '#f8f7f7',
            mobileBackgroundSrc: 'images/phoneBackLight.svg',
            desktopBackgroundSrc: 'images/desktopLight.svg',
            mobileScreenshot: 'images/letterGuessMobile.png',
            desktopScreenshot: 'images/letterGuessDesktop.png',
            mobileScreenshotAlt: '',
            desktopScreenshotAlt: '',
            title: 'Letter Guessing Game',
            path: '/letter-guessing-game',
            motivation: 'To create a simple game using JavaScript in which the goal is for the player to press keys to correctly guess which letter has been randomly selected by the application.',
            description: 'A JavaScript game in which a player has 9 chances to guess which letter has been randomly selected by the application. Once the player is successful or runs out of guesses the game restarts.',
            technicalInfo: 'The application uses Math.random() to choose a value between 97 and 122 corresponding to the Ascii codes for the lowercase alphabet. The corresponding letter is stored in a variable as a string so that player guesses can be compared against it. The player has up to 9 tries to guess the correct letter. Each time the player presses a key the event is captured. The application then checks to see if the key pressed was a lowercase letter and makes sure the player has not already guessed it by comparing it to an array of previous guesses. If these conditions are met the value is compared against the stored target letter. If the values match the player wins, the number of wins displayed will increment and the game will restart. If the user\'s guess is incorrect but they have remaining guesses, the value is added to the array of previous guesses. Each time a letter is added to the previous guesses array, the number of remaining guesses decrements. If the player has no remaining guesses, the game is over. The number of losses displayed will increment and the game will restart. When the game restarts the application chooses a new letter, the number of guesses remaining resets to 9 and the incorrect guesses are cleared.',
            technologies: 'HTML, CSS, JavaScript',
            npmPackages: '',
            futureDev: '',
            role: 'Sole developer responsible for design, code and creation of custom graphics.',
            githubLink: 'https://github.com/lexi-winstanley/letterGuessingGame',
            projectLink: 'https://lexi-winstanley.github.io/letterGuessingGame/',
            javascript: true,
            node: false,
            jQuery: false,
            react: false,
            reactNative: false,
            mySQL: false,
            mongo: false,
            firebase: false,
            customGraphics: true,
            userAuth: false,
            api: false
        }
    ]
}